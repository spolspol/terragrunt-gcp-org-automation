name: Terragrunt Unified (Reusable)

on:
  workflow_call:
    inputs:
      mode:
        description: "Operation mode: apply or validate"
        required: true
        type: string
      resource_type:
        description: "Type of resource (folder, project, vpc-network, vpc-peering, ncc-hub, external-ip, firewall-rules, secrets, instance-template, compute, private-service-access, cloud-router, cloud-nat)"
        required: true
        type: string
      resource_paths:
        description: "JSON array of paths to monitor for changes"
        required: true
        type: string
      template_path:
        description: "Path to common template files"
        required: true
        type: string
      resource_emoji:
        description: "Emoji to use in PR comments"
        required: false
        type: string
        default: "ðŸ“¦"
      resource_description:
        description: "Description of the resource type"
        required: false
        type: string
        default: "Infrastructure resource"
    secrets:
      TF_GOOGLE_CREDENTIALS:
        description: "GCP service account credentials"
        required: true
      ORG_GITHUB_TOKEN:
        description: "GitHub token for accessing private repositories"
        required: false
    outputs:
      operation_status:
        description: "Overall operation status (success or failure)"
        value: ${{ jobs.operation-summary.outputs.overall-status }}
      has_changes:
        description: "Whether changes were detected"
        value: ${{ jobs.detect-changes.outputs.has-changes }}
      changed_resources:
        description: "JSON array of changed resources"
        value: ${{ inputs.resource_paths }}

permissions:
  contents: read
  pull-requests: write

jobs:
  get-env:
    name: get ENV
    uses: ./.github/workflows/common-env.yml

  execute-operation:
    name: "${{ inputs.mode == 'validate' && 'validate' || 'apply' }}: ${{ inputs.resource_emoji }} ${{ matrix.resource }}"
    runs-on: ubuntu-latest
    needs: [get-env]
    env:
      TERRAGRUNT_VERSION: ${{ needs.get-env.outputs.terragrunt_version }}
      TOFU_VERSION: ${{ needs.get-env.outputs.tofu_version }}
      GCP_PROJECT_ID: ${{ needs.get-env.outputs.gcp_project_id }}
      GCP_REGION: ${{ needs.get-env.outputs.gcp_region }}
      TG_EXPERIMENT_MODE: ${{ needs.get-env.outputs.tg_experiment_mode }}
      TG_NON_INTERACTIVE: ${{ needs.get-env.outputs.tg_non_interactive }}
      TG_BACKEND_BOOTSTRAP: ${{ needs.get-env.outputs.tg_backend_bootstrap }}
    strategy:
      matrix:
        resource: ${{ fromJson(inputs.resource_paths) }}
      fail-fast: false
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Extract resource short name
        id: extract-name
        run: |
          # Extract short name from resource path - always use last directory name
          resource_path="${{ matrix.resource }}"
          short_name=$(basename "$resource_path")

          echo "short_name=$short_name" >> $GITHUB_OUTPUT
          echo "Resource short name: $short_name"
          echo "Full resource path: $resource_path"

      - name: Cache Terragrunt and OpenTofu binaries
        id: cache-binaries
        uses: actions/cache@v4
        with:
          path: |
            ~/.local/bin/terragrunt
            ~/.local/bin/tofu
          key: terragrunt-${{ env.TERRAGRUNT_VERSION }}-tofu-${{ env.TOFU_VERSION }}-${{ runner.os }}
          restore-keys: |
            terragrunt-${{ env.TERRAGRUNT_VERSION }}-tofu-${{ env.TOFU_VERSION }}-
            terragrunt-${{ env.TERRAGRUNT_VERSION }}-

      - name: Setup Terragrunt and OpenTofu
        if: steps.cache-binaries.outputs.cache-hit != 'true'
        run: |
          # Create local bin directory
          mkdir -p ~/.local/bin

          # Install Terragrunt
          echo "Downloading Terragrunt v${{ env.TERRAGRUNT_VERSION }}..."
          wget -O ~/.local/bin/terragrunt https://github.com/gruntwork-io/terragrunt/releases/download/v${{ env.TERRAGRUNT_VERSION }}/terragrunt_linux_amd64
          chmod +x ~/.local/bin/terragrunt

          # Install OpenTofu
          echo "Downloading OpenTofu v${{ env.TOFU_VERSION }}..."
          wget -O tofu.tar.gz https://github.com/opentofu/opentofu/releases/download/v${{ env.TOFU_VERSION }}/tofu_${{ env.TOFU_VERSION }}_linux_amd64.tar.gz
          tar -xzf tofu.tar.gz
          chmod +x tofu
          mv tofu ~/.local/bin/
          rm tofu.tar.gz

          echo "Binaries downloaded and cached"

      - name: Create Terraform Plugin Cache Dir
        run: |
          mkdir -p ~/.terraform.d/plugin-cache
          echo "TF_PLUGIN_CACHE_DIR=$HOME/.terraform.d/plugin-cache" >> $GITHUB_ENV

      - name: Cache Terraform Providers
        uses: actions/cache@v4
        with:
          path: ~/.terraform.d/plugin-cache
          # Use run_id to ensure we always save a new cache with the latest providers
          # Since we don't have lock files, this is the best way to keep the cache growing
          key: tf-providers-${{ runner.os }}-${{ env.TOFU_VERSION }}-${{ github.run_id }}
          restore-keys: |
            tf-providers-${{ runner.os }}-${{ env.TOFU_VERSION }}-

      - name: Add binaries to PATH and verify
        run: |
          # Add to PATH for this job
          echo "$HOME/.local/bin" >> $GITHUB_PATH
          export PATH="$HOME/.local/bin:$PATH"

          # Verify installations
          echo "Verifying installations..."
          terragrunt --version
          tofu --version
          echo "All binaries verified"

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.TF_GOOGLE_CREDENTIALS }}

      - name: Setup Google Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          skip_install: false
          install_components: ${{ inputs.resource_type == 'projects' && 'beta' || '' }}

      - name: Configure Git for Private Repositories
        env:
          GITHUB_TOKEN: ${{ secrets.ORG_GITHUB_TOKEN }}
        if: env.GITHUB_TOKEN != ''
        run: |
          echo "Configuring Git authentication for private repositories..."
          git config --global url."https://x-access-token:${GITHUB_TOKEN}@github.com/".insteadOf "https://github.com/"
          echo "Git authentication configured"

      # TEMPORARY: Skip all bootstrap validation until self-hosted runners are available
      - name: Check Bootstrap Resource
        id: check-bootstrap
        run: |
          if [[ "${{ matrix.resource }}" == *"/bootstrap-"* ]]; then
            echo "Bootstrap resource detected: ${{ matrix.resource }}"
            echo "is-bootstrap=true" >> $GITHUB_OUTPUT
            echo "TEMPORARY: Bootstrap validation will be skipped"
            echo "Waiting for self-hosted runners with Kubernetes API access"
          else
            echo "is-bootstrap=false" >> $GITHUB_OUTPUT
          fi

      - name: Fetch GKE Credentials for Bootstrap Resources
        id: gke-auth
        if: steps.check-bootstrap.outputs.is-bootstrap == 'true' && false
        run: |
          echo "Detected bootstrap resource - checking for GKE cluster..."

          # Extract cluster information from resource path
          # Pattern: live/{account}/{env}/{project}/europe-west2/gke/{cluster}/bootstrap-{component}
          RESOURCE_PATH="${{ matrix.resource }}"

          # Extract the cluster directory (parent of bootstrap directory)
          CLUSTER_DIR=$(dirname "$RESOURCE_PATH")
          CLUSTER_NAME=$(basename "$CLUSTER_DIR")

          # Extract project from path
          # Go up from bootstrap -> cluster -> gke -> europe-west2 -> project
          PROJECT_DIR=$(dirname $(dirname $(dirname "$CLUSTER_DIR")))
          PROJECT_ID=$(basename "$PROJECT_DIR")

          # Extract region
          REGION_DIR=$(dirname $(dirname "$CLUSTER_DIR"))
          REGION=$(basename "$REGION_DIR")

          echo "Cluster details:"
          echo "  - Project: $PROJECT_ID"
          echo "  - Region: $REGION"
          echo "  - Cluster: $CLUSTER_NAME"

          # Construct the full GKE cluster name using the naming convention
          # Pattern: {project}-{region-abbr}-{cluster-name}
          # Convert region to abbreviation (europe-west2 -> ew2)
          REGION_ABBR=$(echo "$REGION" | sed 's/europe-west/ew/; s/us-central/uc/; s/asia-east/ae/')
          GKE_CLUSTER_NAME="${PROJECT_ID}-${REGION_ABBR}-${CLUSTER_NAME}"

          echo "Looking for GKE cluster: $GKE_CLUSTER_NAME"

          # Check if cluster exists before trying to get credentials
          if gcloud container clusters describe "$GKE_CLUSTER_NAME" \
            --region="$REGION" \
            --project="$PROJECT_ID" &>/dev/null; then

            echo "Cluster found! Fetching credentials..."
            gcloud container clusters get-credentials "$GKE_CLUSTER_NAME" \
              --region="$REGION" \
              --project="$PROJECT_ID"

            # Verify kubectl access
            if kubectl cluster-info &>/dev/null; then
              echo "Successfully connected to GKE cluster"
              kubectl version --client --short
              echo "using-mock-validation=false" >> $GITHUB_OUTPUT
              echo "cluster-status=exists" >> $GITHUB_OUTPUT
            else
              echo "Warning: Could not verify kubectl connection"
              echo "using-mock-validation=false" >> $GITHUB_OUTPUT
              echo "cluster-status=exists-no-access" >> $GITHUB_OUTPUT
            fi
          else
            echo "GKE cluster '$GKE_CLUSTER_NAME' not found in project '$PROJECT_ID'"
            echo "This is expected during initial validation when the cluster doesn't exist yet."
            echo "The bootstrap resource will use mock outputs for validation."
            echo ""
            echo "Mock Validation Mode Enabled"
            echo "================================"
            echo "The validation will proceed using mock outputs defined in terragrunt.hcl"
            echo "This allows configuration validation before the cluster is created."
            echo ""

            # Set outputs for downstream steps
            echo "using-mock-validation=true" >> $GITHUB_OUTPUT
            echo "cluster-status=not-found" >> $GITHUB_OUTPUT
            echo "cluster-name=$GKE_CLUSTER_NAME" >> $GITHUB_OUTPUT

            # Set environment variable for Terraform to use mock outputs (disabled)
            # echo "BOOTSTRAP_MOCK_MODE=true" >> $GITHUB_ENV
          fi

      - name: Verify resource directory exists
        run: |
          echo "Verifying resource directory exists: ${{ matrix.resource }}"

          if [ ! -d "${{ matrix.resource }}" ]; then
            echo "Error: Resource directory '${{ matrix.resource }}' does not exist!"
            echo "This usually indicates that the resource was deleted but the workflow is still trying to process it."
            echo "The workflow should have filtered out deleted resources, but this one slipped through."
            echo ""
            echo "Possible causes:"
            echo "  1. The resource was recently deleted and git change detection missed it"
            echo "  2. There's a race condition in the workflow"
            echo "  3. The repository contents changed between jobs"
            echo ""
            echo "Skipping this resource to prevent workflow failure."
            exit 1
          fi

          if [ ! -f "${{ matrix.resource }}/terragrunt.hcl" ]; then
            echo "Error: terragrunt.hcl not found in '${{ matrix.resource }}'!"
            echo "This directory exists but doesn't contain a valid Terragrunt configuration."
            exit 1
          fi

          echo "Resource directory and configuration verified"

      - name: Format HCL configuration
        working-directory: ${{ matrix.resource }}
        run: |
          echo "Checking HCL formatting..."

          # Format check (dry-run) using new CLI
          terragrunt hcl fmt --check --diff

          echo "HCL formatting check completed"

      - name: Validate HCL configuration
        working-directory: ${{ matrix.resource }}
        run: |
          echo "Validating HCL configuration..."

          # Validate HCL syntax using new CLI
          terragrunt hcl validate

          # Validate inputs using new CLI
          terragrunt hcl validate --inputs

          echo "HCL validation completed"

      - name: "${{ inputs.mode == 'validate' && 'Validate' || 'Apply' }}: ${{ inputs.resource_emoji }} ${{ matrix.resource }}"
        id: terragrunt
        working-directory: ${{ matrix.resource }}
        env:
          GITHUB_TOKEN: ${{ secrets.ORG_GITHUB_TOKEN }}
        run: |
          echo "Working in directory: ${{ matrix.resource }}"

          # TEMPORARY: Skip bootstrap validation until self-hosted runners available
          if [[ "${{ steps.check-bootstrap.outputs.is-bootstrap }}" == "true" ]]; then
            echo ""
            echo "Bootstrap Validation Temporarily Skipped"
            echo "============================================"
            echo "Bootstrap ArgoCD validation requires self-hosted runners with:"
            echo "  - Deployment to GKE cluster"
            echo "  - Workload identity authentication"
            echo "  - Kubernetes API access"
            echo ""
            echo "Manual validation required: terragrunt run plan"
            echo "============================================"
            echo "result=no-changes" >> $GITHUB_OUTPUT
            echo "plan-summary=Skipped - waiting for self-hosted runners" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Mock validation logic (disabled while bootstrap is skipped)
          # This will be re-enabled after self-hosted runners are available
          if false && [[ "${{ matrix.resource }}" == *"/bootstrap-"* ]] && [[ "$BOOTSTRAP_MOCK_MODE" == "true" ]]; then
            echo ""
            echo "Bootstrap Resource Mock Validation"
            echo "====================================="
            echo "GKE cluster does not exist yet - using mock outputs"
            echo "This validation will verify the configuration syntax and structure"
            echo "Real validation will occur after the GKE cluster is created"
            echo ""
            echo "mock-validation=true" >> $GITHUB_OUTPUT
          else
            echo "mock-validation=false" >> $GITHUB_OUTPUT
          fi

          if [ -d ".terraform/providers" ] && [ "$(ls -A .terraform/providers 2>/dev/null)" ]; then
            echo "Local providers found"
          else
            echo "No local providers found"
          fi

          # Initialize Terragrunt using new CLI
          echo "Initializing Terragrunt..."
          terragrunt run init

          # Prepare plan file name
          export PLAN_TIMESTAMP=$(date -u +%Y%m%dT%H%M%SZ)
          export PLAN_SHORT_NAME=$(basename "$PWD")
          export PLAN_FILE_NAME="${PLAN_TIMESTAMP}-${{ inputs.resource_type }}-${PLAN_SHORT_NAME}.plan"

          echo "Plan file name: $PLAN_FILE_NAME"

          if [ "${{ inputs.mode }}" == "apply" ]; then
            # Apply the configuration using new CLI
            set +e
            echo "Running Terragrunt apply..."
            terragrunt run apply -- -auto-approve
            APPLY_EXIT_CODE=$?
            set -e

            if [ $APPLY_EXIT_CODE -eq 0 ]; then
              echo "Terragrunt apply completed successfully"
              echo "result=success" >> $GITHUB_OUTPUT
            else
              echo "Terragrunt apply failed with exit code: $APPLY_EXIT_CODE"
              echo "result=error" >> $GITHUB_OUTPUT
              exit 1
            fi
          else
            # Plan the configuration for validation and capture output using new CLI
            set +e
            echo "Running Terragrunt plan with detailed output..."
            # Use PIPESTATUS to capture the exit code of terragrunt
            terragrunt run plan -- -detailed-exitcode -compact-warnings -no-color | tee "$PLAN_FILE_NAME"
            PLAN_EXIT_CODE=${PIPESTATUS[0]}
            TEE_EXIT_CODE=${PIPESTATUS[1]}
            set -e
            echo "Terragrunt plan exit code: $PLAN_EXIT_CODE"
            echo "Tee exit code: $TEE_EXIT_CODE"
            echo "Full pipeline status: ${PIPESTATUS[@]}"
            echo "Plan output file size: $(wc -l < "$PLAN_FILE_NAME" 2>/dev/null || echo 0) lines"
            head -10 "$PLAN_FILE_NAME" || echo "Could not read plan output"
            tail -10 "$PLAN_FILE_NAME" || echo "Could not read plan output"
            # Create a sanitized plan output for PR comments (remove sensitive info)
            if [ -f "$PLAN_FILE_NAME" ]; then
              grep -E "(Plan:|No changes|Error:|Warning:|\+|\-|~|will be)" "$PLAN_FILE_NAME" | head -50 > plan_summary.txt || echo "Plan output processing failed" > plan_summary.txt
            fi
            if [ $PLAN_EXIT_CODE -eq 0 ]; then
              echo "result=no-changes" >> $GITHUB_OUTPUT
              echo "plan-summary=No changes detected" >> $GITHUB_OUTPUT
              echo "No changes detected"
            elif [ $PLAN_EXIT_CODE -eq 2 ]; then
              echo "result=changes-detected" >> $GITHUB_OUTPUT
              if [ -f plan_summary.txt ]; then
                PLAN_SUMMARY=$(cat plan_summary.txt | sed ':a;N;$!ba;s/\n/\\n/g' | head -c 1000)
                echo "plan-summary=$PLAN_SUMMARY" >> $GITHUB_OUTPUT
              else
                echo "plan-summary=Changes detected (plan summary unavailable)" >> $GITHUB_OUTPUT
              fi
              echo "Changes detected (this is expected for validation)"
            else
              echo "result=error" >> $GITHUB_OUTPUT
              echo "plan-summary=Plan failed with exit code $PLAN_EXIT_CODE" >> $GITHUB_OUTPUT
              echo "Terragrunt plan failed with exit code: $PLAN_EXIT_CODE"
              exit 1
            fi
          fi

  update-pr-comment:
    name: comment
    runs-on: ubuntu-latest
    needs: [get-env, execute-operation]
    if: github.event_name == 'pull_request' && inputs.mode == 'validate'
    steps:
      - name: Generate PR comment
        id: comment
        run: |
          CHANGED_RESOURCES='${{ inputs.resource_paths }}'
          EXECUTE_STATUS="${{ needs.execute-operation.result }}"
          RESOURCE_SHORT_NAME='${{ inputs.resource_type }}'

          if [ "$CHANGED_RESOURCES" == "[]" ]; then
            COMMENT_BODY="${{ inputs.resource_emoji }} **$RESOURCE_SHORT_NAME**: No changes detected"
          else
            # Build simple comment
            {
              echo "${{ inputs.resource_emoji }} **$RESOURCE_SHORT_NAME Validation Results**"
              echo ""

              # Bootstrap resources are temporarily skipped
              if [[ "$RESOURCE_SHORT_NAME" == "bootstrap" ]]; then
                echo "**Bootstrap Validation Temporarily Disabled**"
                echo ""
                echo "Waiting for self-hosted runners with Kubernetes API access"
                echo "**Status: SKIPPED**"
                echo "**Action Required:** Validate manually with \`terragrunt run plan\`"
              else
                # Normal validation status for non-bootstrap resources
                if [ "$EXECUTE_STATUS" == "success" ]; then
                  echo "**Status: VALIDATION PASSED**"
                else
                  echo "**Status: VALIDATION FAILED**"
                fi
              fi
              echo ""

              # Count total resources
              RESOURCE_COUNT=$(echo "$CHANGED_RESOURCES" | jq -r '. | length')

              echo "**Resources Validated:** $RESOURCE_COUNT"
              echo "**Resource Type:** $RESOURCE_SHORT_NAME"
              if [ "${{ inputs.mode }}" == "apply" ]; then
                echo "**Operation:** Apply (resources were deployed)"
              else
                echo "**Operation:** Validate (dry-run planning)"
              fi
              echo "**Commit:** \`${{ github.sha }}\`"
              echo "**Workflow:** [View Full Details](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})"
              echo ""

              # Commands Status Section
              if [ "$EXECUTE_STATUS" == "success" ]; then
                echo "### Commands Status:"
                echo "- \`terragrunt hcl fmt --check\` PASSED"
                echo "- \`terragrunt hcl validate\` PASSED"
                echo "- \`terragrunt hcl validate --inputs\` PASSED"
                echo "- \`terragrunt run init\` PASSED"
                if [ "${{ inputs.mode }}" == "apply" ]; then
                  echo "- \`terragrunt run apply\` PASSED"
                else
                  if [[ "$RESOURCE_SHORT_NAME" == "bootstrap" ]]; then
                    echo "- Validation skipped (waiting for self-hosted runners)"
                  else
                    echo "- \`terragrunt run plan\` PASSED"
                  fi
                fi
              else
                echo "### Commands Status:"
                echo "- \`terragrunt hcl fmt --check\` UNKNOWN"
                echo "- \`terragrunt hcl validate\` UNKNOWN"
                echo "- \`terragrunt hcl validate --inputs\` UNKNOWN"
                echo "- \`terragrunt run init\` UNKNOWN"
                if [ "${{ inputs.mode }}" == "apply" ]; then
                  echo "- \`terragrunt run apply\` FAILED"
                else
                  echo "- \`terragrunt run plan\` FAILED"
                fi
              fi
              echo ""

              # Resource Details Table
              echo "### Resource Validation Details"
              echo ""
              echo "| Resource Path | Status | Plan Summary | Workflow |"
              echo "|---------------|--------|--------------|-----------|"

              # Show each resource with detailed status
              echo "$CHANGED_RESOURCES" | jq -r '.[]' | while read -r resource; do
                if [ -n "$resource" ]; then
                  # Determine individual resource status
                  if [ "$EXECUTE_STATUS" == "success" ]; then
                    RESOURCE_STATUS_ICON="PASSED"
                    RESOURCE_STATUS_TEXT="Passed"

                    # Get plan summary based on resource type
                    if [[ "${{ inputs.resource_type }}" == "bootstrap" ]]; then
                       PLAN_SUMMARY="Bootstrap validation skipped (waiting for self-hosted runners)"
                    else
                       PLAN_SUMMARY="${{ inputs.resource_emoji }} ${{ inputs.resource_description }}"
                    fi
                  else
                    RESOURCE_STATUS_ICON="FAILED"
                    RESOURCE_STATUS_TEXT="Failed"
                    PLAN_SUMMARY="Validation failed - check logs"
                  fi

                  # Create workflow links
                  WORKFLOW_LINK="[Plan Output](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})"

                  # Truncate long resource paths for better display
                  DISPLAY_RESOURCE="$resource"
                  if [ ${#DISPLAY_RESOURCE} -gt 50 ]; then
                    DISPLAY_RESOURCE="...${DISPLAY_RESOURCE: -47}"
                  fi

                  echo "| $DISPLAY_RESOURCE | $RESOURCE_STATUS_ICON $RESOURCE_STATUS_TEXT | $PLAN_SUMMARY | $WORKFLOW_LINK |"
                fi
              done

              # Results Section
              echo ""
              if [ "$EXECUTE_STATUS" == "success" ]; then
                if [ "${{ inputs.mode }}" == "apply" ]; then
                  echo "### Deployment Results:"
                  echo "- **Infrastructure updated** successfully"
                  echo "- **All deployment steps** completed"
                  echo "- **Deployment logs** available in workflow run"
                else
                  echo "### Validation Results:"
                  echo "- All $RESOURCE_SHORT_NAME configurations passed validation"
                  echo "- Terragrunt initialization completed successfully"
                  echo "- Terraform syntax and dependency validation passed"
                  echo "- Terraform plan executed without errors"
                fi
              else
                echo "### Validation Failures:"
                echo "- One or more $RESOURCE_SHORT_NAME configurations failed validation"
                echo "- Check the workflow logs for detailed error information"
                echo "- Common issues: syntax errors, missing dependencies, or configuration conflicts"
              fi

              echo ""
              echo "### Next Steps:"
              if [ "$EXECUTE_STATUS" == "success" ]; then
                if [ "${{ inputs.mode }}" == "apply" ]; then
                  echo "- Resources have been successfully deployed"
                  echo "- Verify the deployed resources in the GCP console"
                  echo "- Review the deployment logs for detailed information"
                else
                  echo "- All validations passed - ready for review and merge"
                  echo "- Merge this PR to trigger automatic deployment"
                  echo "- Review the planned changes in the workflow logs"
                fi
              else
                echo "- Fix the validation errors before proceeding"
                echo "- Check the workflow logs for specific error details"
                echo "- Push new commits to re-trigger validation"
              fi

              echo ""
              echo "**Workflow Logs:** Plan output files are available in the workflow run for detailed review."
            } > /tmp/comment_body.txt

            # Read the comment body from file
            COMMENT_BODY=$(cat /tmp/comment_body.txt)
            rm -f /tmp/comment_body.txt
          fi

          # Use a more robust method to set the output
          {
            echo "comment-body<<COMMENT_EOF"
            echo "$COMMENT_BODY"
            echo "COMMENT_EOF"
          } >> $GITHUB_OUTPUT

      - name: Update PR comment
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // Read comment body from environment variable to avoid template literal issues
            const commentBody = process.env.COMMENT_BODY;

            // Find existing comment
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.data.find(comment => {
              const isBot = comment.user.type === 'Bot';
              const containsResource = comment.body.includes('${{ inputs.resource_type }}');
              return isBot && containsResource;
            });

            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: commentBody
              });
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: commentBody
              });
            }
        env:
          COMMENT_BODY: ${{ steps.comment.outputs.comment-body }}

  orchestration-gate:
    name: checkpoint
    runs-on: ubuntu-latest
    needs: [get-env, execute-operation]
    if: always()
    outputs:
      overall-status: ${{ steps.gate.outputs.status }}
    steps:
      - name: Determine overall status
        id: gate
        run: |
          DETECT_STATUS="success"
          EXECUTE_STATUS="${{ needs.execute-operation.result }}"
          HAS_CHANGES="true"
          RESOURCE_SHORT_NAME='${{ inputs.resource_type }}'

          echo "Detect changes status: $DETECT_STATUS"
          echo "Execute operation status: $EXECUTE_STATUS"
          echo "Has changes: $HAS_CHANGES"

          if [ "$HAS_CHANGES" == "false" ]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "No changes detected for $RESOURCE_SHORT_NAME"
            exit 0
          fi

          # Check if the execute-operation job completed successfully
          if [ "$EXECUTE_STATUS" == "success" ]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "$RESOURCE_SHORT_NAME operation completed successfully"
          else
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "$RESOURCE_SHORT_NAME operation failed with status: $EXECUTE_STATUS"
            exit 1
          fi
